---
globs: src/components/**
description: 组件库标准结构、样式管理和开发流程规范
---

# 组件库结构规范

本规范定义了 LobeChat Mobile 组件库的标准结构、样式管理方式和开发流程。

## 组件目录结构

每个组件应遵循以下标准目录结构：

```
src/components/ComponentName/
├── ComponentName.tsx    # 组件主文件
├── index.ts            # 导出文件
├── index.md            # 组件文档
├── style.ts            # 样式定义
├── type.ts             # TypeScript 类型定义
└── demos/              # 示例目录
    ├── index.tsx       # 示例入口
    ├── basic.tsx       # 基础示例
    └── ...             # 其他示例
```

### 文件职责说明

#### 1. `ComponentName.tsx` - 组件主文件

组件的核心实现文件，命名采用 PascalCase：

```tsx
import React, { memo, useMemo } from 'react';
import { cva } from '@/components/styles';
import { useStyles } from './style';
import type { ComponentNameProps } from './type';

const ComponentName = memo<ComponentNameProps>(
  ({ variant = 'default', children, style, ...rest }) => {
    const { styles } = useStyles();

    // 使用 CVA 管理样式变体
    const variants = useMemo(
      () =>
        cva(styles.root, {
          variants: {
            variant: {
              default: styles.default,
              primary: styles.primary,
            },
          },
          compoundVariants: [
            {
              variant: 'primary',
              pressed: true,
              style: styles.primaryActive,
            },
          ],
          defaultVariants: {
            variant: 'default',
          },
        }),
      [styles],
    );

    return (
      <View
        style={({ hovered, pressed }) => [
          variants({ variant, hovered, pressed }),
          style,
        ]}
        {...rest}
      >
        {children}
      </View>
    );
  },
);

ComponentName.displayName = 'ComponentName';

export default ComponentName;
```

**关键要点：**
- 使用 `memo` 包裹组件优化性能
- 从 `./style` 导入 `useStyles` 钩子
- 从 `./type` 导入类型定义
- 使用 `cva` 管理复杂的样式变体逻辑
- 使用 `useMemo` 缓存 CVA 配置，依赖 `styles`
- 设置 `displayName` 便于调试

#### 2. `style.ts` - 样式定义文件

使用 `createStyles` 创建主题感知的样式：

```tsx
import { createStyles } from '@/components/styles';

export const useStyles = createStyles(({ token, stylish }) => ({
  // 基础样式
  root: {
    borderRadius: token.borderRadius,
    position: 'relative' as const,
  },

  // 变体样式 - 使用 stylish 预设
  default: stylish.variantFilled,
  primary: stylish.variantOutlined,

  // 交互状态样式
  primaryActive: stylish.variantOutlinedActive,
  primaryHover: stylish.variantOutlinedHover,

  // 附加效果
  shadow: stylish.shadow,
  glass: stylish.blur,
}));
```

**关键要点：**
- 统一使用 `createStyles` 工厂函数
- 通过 `token` 访问主题变量（颜色、间距、圆角等）
- 通过 `stylish` 访问预设样式（变体、阴影、模糊等）
- 使用 `as const` 确保字面量类型
- 样式名称应语义化，便于在 CVA 中引用

#### 3. `type.ts` - 类型定义文件

定义组件的 Props 接口：

```tsx
import type { ViewProps } from 'react-native';

export interface ComponentNameProps extends ViewProps {
  /**
   * 样式变体
   * @default 'default'
   */
  variant?: 'default' | 'primary' | 'secondary';

  /**
   * 是否显示阴影
   */
  shadow?: boolean;

  /**
   * 是否启用玻璃效果
   */
  glass?: boolean;

  /**
   * 点击回调
   */
  onPress?: () => void;
}
```

**关键要点：**
- 继承自基础组件的 Props（如 `ViewProps`, `FlexboxProps`）
- 为每个 prop 添加 JSDoc 注释
- 使用 `@default` 标注默认值
- 使用字面量类型限制可选值

#### 4. `index.ts` - 导出文件

标准导出格式：

```tsx
export { default } from './ComponentName';
export type * from './type';
```

**关键要点：**
- 默认导出组件本身
- 使用 `export type *` 导出所有类型

#### 5. `index.md` - 组件文档

使用 YAML frontmatter 定义元数据：

```markdown
---
group: Layout
title: ComponentName
description: 组件的简短描述，说明主要功能和特点。
---

## Features

- ✅ 功能特性 1
- ✅ 功能特性 2
- ✅ TypeScript 支持
- ✅ 主题适配

## Basic Usage

\`\`\`tsx
import { ComponentName } from '@lobehub/ui-rn';

<ComponentName variant="primary">
  <Text>示例内容</Text>
</ComponentName>
\`\`\`

## API

详细的 Props 说明...
```

**关键要点：**
- `group`: 组件分类（Layout、Form、Display 等）
- `title`: 组件名称
- `description`: 简短描述
- 包含功能特性、使用示例、API 文档

#### 6. `demos/` - 示例目录

demos 目录用于存放组件的交互式示例，这些示例会在 Playground 中展示。

**目录结构：**

```
demos/
├── index.tsx       # Demo 配置入口（必需）
├── basic.tsx       # 基础用法示例（必需）
├── variants.tsx    # 变体示例
├── sizes.tsx       # 尺寸示例
├── colors.tsx      # 颜色示例
├── states.tsx      # 状态示例
└── ...             # 其他特定功能示例
```

##### 6.1 `demos/index.tsx` - Demo 配置文件

配置文件定义了所有 demo 的元数据和加载方式：

```tsx
import type { DemoConfig } from '@lobehub/ui-rn';
import React from 'react';

import BasicDemo from './basic';
import ColorsDemo from './colors';
import SizesDemo from './sizes';
import VariantsDemo from './variants';

const demos: DemoConfig = [
  { component: <BasicDemo />, key: 'basic', title: '基础用法' },
  { component: <VariantsDemo />, key: 'variants', title: '不同视觉风格' },
  { component: <SizesDemo />, key: 'sizes', title: '尺寸' },
  { component: <ColorsDemo />, key: 'colors', title: '颜色' },
];

export default demos;
```

**DemoConfig 类型定义：**

```tsx
interface DemoItem {
  /** Demo 组件实例 */
  component: React.ReactNode;
  /** Demo 唯一标识，使用 kebab-case */
  key: string;
  /** Demo 标题，用于在 Playground 中显示 */
  title: string;
}

type DemoConfig = DemoItem[];
```

**关键要点：**
- 从 `@lobehub/ui-rn` 导入 `DemoConfig` 类型
- 导入所有 demo 组件（使用 PascalCase + Demo 后缀）
- 配置数组按重要性排序，`basic` 应始终放在第一位
- `key` 使用 kebab-case 命名（如 `basic`, `variants`, `disabled-state`）
- `title` 使用中文描述，简洁明了
- 使用默认导出导出配置数组

##### 6.2 Demo 文件规范

每个 demo 文件应遵循以下规范：

```tsx
// demos/basic.tsx
import { ComponentName, Flexbox } from '@lobehub/ui-rn';
import React from 'react';
import { Text } from 'react-native';

export default () => {
  return (
    <Flexbox gap={16}>
      <ComponentName variant="default">
        <Text>默认示例</Text>
      </ComponentName>
      <ComponentName variant="primary">
        <Text>主要示例</Text>
      </ComponentName>
    </Flexbox>
  );
};
```

**关键要点：**
- 使用默认导出
- 使用箭头函数组件
- 不需要包裹额外的容器组件（Playground 会自动处理）
- 使用 `Flexbox` 组件进行布局，设置合适的 `gap` 值
- 示例应简洁明了，专注于展示单一特性或相关特性组

##### 6.3 Demo 文件命名规范

推荐的 demo 文件名及其用途：

| 文件名 | 用途 | 优先级 |
|--------|------|--------|
| `basic.tsx` | 基础用法，展示最常见的使用场景 | 必需 ⭐ |
| `variants.tsx` | 展示所有样式变体（filled, outlined 等） | 推荐 |
| `sizes.tsx` | 展示不同尺寸（small, medium, large） | 推荐 |
| `colors.tsx` | 展示不同颜色主题 | 可选 |
| `disabled.tsx` | 展示禁用状态 | 可选 |
| `loading.tsx` | 展示加载状态 | 可选 |
| `interactive.tsx` | 展示交互行为（点击、hover 等） | 可选 |
| `layout.tsx` | 展示布局应用场景 | 可选 |
| `advanced.tsx` | 展示高级用法或复杂场景 | 可选 |

##### 6.4 Demo 最佳实践

**✅ 推荐的做法：**

```tsx
// 1. 清晰的分组和间距
export default () => {
  return (
    <Flexbox gap={16}>
      <Text style={{ fontWeight: 'bold' }}>默认变体</Text>
      <Block variant="filled">
        <Text>Filled Block</Text>
      </Block>

      <Text style={{ fontWeight: 'bold' }}>轮廓变体</Text>
      <Block variant="outlined">
        <Text>Outlined Block</Text>
      </Block>
    </Flexbox>
  );
};

// 2. 使用状态展示交互
export default () => {
  const [count, setCount] = useState(0);

  return (
    <Button onPress={() => setCount(c => c + 1)}>
      <Text>点击次数: {count}</Text>
    </Button>
  );
};

// 3. 使用 Alert 或 Toast 展示反馈
export default () => {
  return (
    <Button onPress={() => Alert.alert('提示', '按钮被点击了')}>
      <Text>点击我</Text>
    </Button>
  );
};
```

**❌ 避免的做法：**

```tsx
// ❌ 不要使用外部状态管理
import { useStore } from '@/store';  // 避免

// ❌ 不要使用复杂的业务逻辑
export default () => {
  const data = fetchDataFromAPI();  // 避免
  // ...
};

// ❌ 不要使用过多嵌套
export default () => {
  return (
    <View>
      <View>
        <View>
          <View>  // 过度嵌套
            <Component />
          </View>
        </View>
      </View>
    </View>
  );
};

// ❌ 不要在 demo 中定义复杂组件
const ComplexComponent = () => { /* 大量代码 */ };  // 应该独立文件
export default () => <ComplexComponent />;
```

##### 6.5 常见 Demo 模板

**基础用法模板：**

```tsx
import { ComponentName } from '@lobehub/ui-rn';
import React from 'react';

export default () => {
  return <ComponentName>基本示例</ComponentName>;
};
```

**变体展示模板：**

```tsx
import { ComponentName, Flexbox } from '@lobehub/ui-rn';
import React from 'react';

export default () => {
  return (
    <Flexbox gap={16}>
      <ComponentName variant="filled">Filled</ComponentName>
      <ComponentName variant="outlined">Outlined</ComponentName>
      <ComponentName variant="borderless">Borderless</ComponentName>
    </Flexbox>
  );
};
```

**交互示例模板：**

```tsx
import { ComponentName, Flexbox } from '@lobehub/ui-rn';
import React, { useState } from 'react';
import { Alert, Text } from 'react-native';

export default () => {
  const [value, setValue] = useState('');

  return (
    <Flexbox gap={16}>
      <ComponentName
        value={value}
        onChange={setValue}
        onPress={() => Alert.alert('提示', `当前值: ${value}`)}
      />
      <Text>当前值: {value}</Text>
    </Flexbox>
  );
};
```

## CVA (Class Variance Authority) 用法

CVA 用于管理组件的样式变体逻辑，提供类型安全的样式组合。

### 基础用法

```tsx
import { cva } from '@/components/styles';

const variants = useMemo(
  () =>
    cva(styles.root, {
      // 定义变体
      variants: {
        variant: {
          filled: styles.filled,
          outlined: styles.outlined,
          borderless: styles.borderless,
        },
        size: {
          small: styles.small,
          medium: styles.medium,
          large: styles.large,
        },
      },
      // 默认值
      defaultVariants: {
        variant: 'filled',
        size: 'medium',
      },
    }),
  [styles],
);

// 使用变体
<View style={variants({ variant: 'outlined', size: 'large' })} />
```

### 复合变体 (Compound Variants)

处理多个变体组合时的特殊样式：

```tsx
const variants = useMemo(
  () =>
    cva(styles.root, {
      variants: {
        variant: {
          filled: styles.filled,
          outlined: styles.outlined,
        },
        hovered: {
          false: null,
          true: styles.hover,
        },
        pressed: {
          false: null,
          true: styles.pressed,
        },
      },
      // 复合变体：特定组合的特殊样式
      compoundVariants: [
        {
          variant: 'outlined',
          hovered: true,
          style: styles.outlinedHover,
        },
        {
          variant: 'outlined',
          pressed: true,
          style: styles.outlinedActive,
        },
        {
          variant: 'filled',
          pressed: true,
          style: styles.filledActive,
        },
      ],
      defaultVariants: {
        variant: 'filled',
      },
    }),
  [styles],
);
```

### 与交互状态结合

结合 React Native 的交互状态（hovered、pressed）：

```tsx
<Pressable
  style={({ hovered, pressed }) => [
    variants({ variant, hovered, pressed }),
    style,
  ]}
>
  {children}
</Pressable>
```

**CVA 最佳实践：**
- 始终使用 `useMemo` 缓存 CVA 配置，避免重复创建
- 将 `styles` 对象加入依赖数组
- 将交互状态（hovered、pressed）作为变体处理
- 使用 `compoundVariants` 处理组合逻辑，保持代码清晰
- 为布尔变体提供 `false: null` 选项

## 开发流程

### 添加新组件

1. **创建组件目录结构**
   ```bash
   mkdir -p src/components/NewComponent/demos
   ```

2. **创建必需文件**

   按以下顺序创建文件：

   - `type.ts` - TypeScript 类型定义
   - `style.ts` - 样式定义
   - `NewComponent.tsx` - 组件实现
   - `index.ts` - 导出文件
   - `index.md` - 组件文档（包含 frontmatter）
   - `demos/basic.tsx` - 基础示例
   - `demos/index.tsx` - Demo 配置文件（必需）

3. **配置 demos/index.tsx**

   创建 demo 配置文件，引入所有示例：

   ```tsx
   import type { DemoConfig } from '@lobehub/ui-rn';
   import React from 'react';

   import BasicDemo from './basic';
   // 引入其他 demo...

   const demos: DemoConfig = [
     { component: <BasicDemo />, key: 'basic', title: '基础用法' },
     // 添加其他 demo 配置...
   ];

   export default demos;
   ```

4. **更新组件索引**

   在 [src/components/index.ts](mdc:src/components/index.ts) 中添加导出：
   ```tsx
   export { default as NewComponent， type NewComponentProps } from './NewComponent';
   ```

5. **生成 Playground 数据** ⚠️

   添加或修改组件后，**必须**运行以下命令更新 Playground：

   ```bash
   pnpm run build:playground
   ```

   或使用完整命令：

   ```bash
   pnpm run workflow:playground
   ```

   这个命令会：
   - 扫描所有组件目录
   - 读取 `index.md` 中的 frontmatter 元数据
   - 生成 `app/playground/.data/index.json` 数据文件
   - 生成 `app/playground/.data/import.ts` 导入文件
   - 更新 Playground 应用的组件列表

   **注意**：如果不运行此命令，新组件将不会出现在 Playground 中。

### 更新现有组件

1. **修改组件实现**
   - 更新 `ComponentName.tsx` 的组件逻辑
   - 更新 `style.ts` 的样式定义
   - 更新 `type.ts` 的类型定义

2. **更新文档和示例**
   - 更新 `index.md` 文档，确保示例代码与实际 API 一致
   - 如果添加了新功能，创建对应的 demo 文件（如 `demos/newFeature.tsx`）
   - 在 `demos/index.tsx` 中注册新的 demo

3. **运行 Playground 更新**
   - 如果修改了组件的 `group` 或 `title`，运行 `pnpm run build:playground`
   - 如果添加了新的 demo，也需要运行此命令

### 测试组件

在 Playground 中测试组件：

```bash
# 启动开发服务器
pnpm start

# 在 iOS 模拟器中运行
pnpm ios

# 在 Android 模拟器中运行
pnpm android
```

导航到 Playground 页面查看和测试组件。

## 命名规范

- **组件文件**：PascalCase（如 `ActionIcon.tsx`）
- **样式文件**：camelCase（如 `style.ts`）
- **类型文件**：camelCase（如 `type.ts`）
- **导出文件**：固定名称 `index.ts`
- **文档文件**：固定名称 `index.md`

### Demo 命名规范

- **Demo 文件**：camelCase（如 `basic.tsx`, `variants.tsx`, `disabled.tsx`）
- **Demo 配置文件**：固定名称 `demos/index.tsx`
- **Demo 导入名称**：PascalCase + Demo 后缀（如 `BasicDemo`, `VariantsDemo`）
- **Demo key**：kebab-case（如 `'basic'`, `'variants'`, `'disabled-state'`）
- **Demo title**：中文描述（如 `'基础用法'`, `'不同视觉风格'`, `'禁用状态'`）

**示例：**

```tsx
// demos/disabled-state.tsx
export default () => { /* ... */ };

// demos/index.tsx
import DisabledStateDemo from './disabled-state';

const demos: DemoConfig = [
  { component: <DisabledStateDemo />, key: 'disabled-state', title: '禁用状态' },
];
```

## 样式最佳实践

1. **优先使用 stylish 预设**
   ```tsx
   filled: stylish.variantFilled,  // ✅ 推荐
   filled: { backgroundColor: token.colorBgContainer }, // ❌ 避免
   ```

2. **保持样式的可组合性**
   ```tsx
   // ✅ 好的做法：细粒度的样式定义
   root: { borderRadius: token.borderRadius },
   shadow: stylish.shadow,
   glass: stylish.blur,

   // ❌ 避免：耦合多个效果
   rootWithShadow: { ...stylish.shadow, borderRadius: token.borderRadius },
   ```

3. **使用语义化的样式名称**
   ```tsx
   // ✅ 清晰的语义
   variantPrimary: stylish.variantFilled,
   variantPrimaryActive: stylish.variantFilledActive,

   // ❌ 避免无意义的名称
   style1: stylish.variantFilled,
   activeStyle: stylish.variantFilledActive,
   ```

## 相关文件参考

### 组件结构示例

- [Block 组件实现](mdc:src/components/Block/Block.tsx) - CVA 用法示例
- [Block 样式定义](mdc:src/components/Block/style.ts) - createStyles 示例
- [Block 类型定义](mdc:src/components/Block/type.ts) - Props 接口示例
- [Block 文档](mdc:src/components/Block/index.md) - 组件文档示例

### Demo 示例

- [Block Demo 配置](mdc:src/components/Block/demos/index.tsx) - Demo 配置文件示例
- [Block 基础示例](mdc:src/components/Block/demos/basic.tsx) - 基础 demo 示例
- [Block 交互示例](mdc:src/components/Block/demos/clickable.tsx) - 交互 demo 示例
- [ActionIcon Demo 配置](mdc:src/components/ActionIcon/demos/index.tsx) - 多 demo 配置示例

### 工具和类型

- [DemoConfig 类型定义](mdc:src/components/types.ts) - Demo 配置类型
- [Playground 数据生成脚本](mdc:scripts/playground/index.ts) - 自动化流程
- [组件导出索引](mdc:src/components/index.ts) - 导出规范

## 快速检查清单

在提交新组件或更新组件之前，请确认：

### 新组件清单

- [ ] 创建了组件目录 `src/components/ComponentName/`
- [ ] 创建了 `ComponentName.tsx` 主文件
- [ ] 创建了 `type.ts` 类型定义
- [ ] 创建了 `style.ts` 样式定义
- [ ] 创建了 `index.ts` 导出文件
- [ ] 创建了 `index.md` 文档，包含正确的 frontmatter（group, title, description）
- [ ] 创建了 `demos/basic.tsx` 基础示例
- [ ] 创建了 `demos/index.tsx` 配置文件
- [ ] 在 `src/components/index.ts` 中添加了导出
- [ ] 运行了 `pnpm run build:playground`
- [ ] 在 Playground 中测试了组件

### Demo 清单

- [ ] `demos/index.tsx` 从 `@lobehub/ui-rn` 导入了 `DemoConfig` 类型
- [ ] 所有 demo 文件使用默认导出箭头函数组件
- [ ] `demos/index.tsx` 中的 demo 配置使用了正确的命名：
  - `key` 使用 kebab-case
  - `title` 使用中文
  - 导入名称使用 PascalCase + Demo 后缀
- [ ] `basic` demo 放在配置数组的第一位
- [ ] demo 代码简洁，专注于单一功能展示

### 样式清单

- [ ] 使用 `createStyles` 创建样式
- [ ] 优先使用 `stylish` 预设而非自定义样式
- [ ] 从 `token` 获取主题变量
- [ ] 如果使用 CVA，已用 `useMemo` 包裹并依赖 `styles`
- [ ] 样式名称语义化清晰

### 文档清单

- [ ] `index.md` 包含正确的 frontmatter
- [ ] 文档包含 Features 列表
- [ ] 文档包含 Basic Usage 示例
- [ ] 文档示例代码与实际 API 一致
